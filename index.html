<!DOCTYPE html>
<html lang="fi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pörssisähkön keskihinnan ennuste</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #ffffff;
            --card-bg: #1e293b;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent-color: #38bdf8;
            --accent-glow: rgba(56, 189, 248, 0.2);
            --success: #4ade80;
            --warning: #fbbf24;
            --danger: #f87171;
            --font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: var(--font-family);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            color: #0f172a;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #0f172a 0%, var(--accent-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            color: #475569;
            font-size: 1.1rem;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            width: 100%;
            max-width: 1200px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 1rem;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .date {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .weekday {
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .price-container {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1.5rem 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
        }

        .price-value {
            font-size: 3.5rem;
            font-weight: 800;
            line-height: 1;
            margin-bottom: 0.5rem;
        }

        .price-unit {
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 0.5rem;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .footer {
            margin-top: 4rem;
            color: #475569;
            font-size: 0.9rem;
            text-align: center;
            max-width: 600px;
        }

        .coeff-section {
            margin-top: 2rem;
            padding: 1.5rem;
            border-radius: 1rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            text-align: left;
        }

        .coeff-section h2 {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: #0f172a;
        }

        .coeff-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .coeff-field {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            font-size: 0.9rem;
            color: #0f172a;
        }

        .coeff-field input {
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid #cbd5f5;
            font-size: 0.95rem;
        }

        .coeff-actions {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .coeff-actions button {
            padding: 0.55rem 1rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }

        .coeff-save {
            background: #2563eb;
            color: #fff;
        }

        .coeff-reset {
            background: #e2e8f0;
            color: #0f172a;
        }

        .history-comparison {
            margin-top: 2rem;
            padding: 1.25rem;
            border-radius: 1rem;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            text-align: left;
            color: #0f172a;
        }

        .history-comparison h3 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0.75rem;
            font-size: 0.9rem;
        }

        .history-table th,
        .history-table td {
            border: 1px solid #e2e8f0;
            padding: 0.5rem 0.6rem;
            text-align: left;
        }

        .history-table th {
            background: #f1f5f9;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            grid-column: 1 / -1;
            color: var(--text-secondary);
            font-size: 1.2rem;
        }

        /* Price Colors */
        .price-low {
            color: var(--success);
        }

        .price-mid {
            color: var(--warning);
        }

        .price-high {
            color: var(--danger);
        }
    </style>
</head>

<body>
    <header>
        <h1>Pörssisähkön keskihinnan ennuste</h1>
        <div class="subtitle">Ennuste perustuen Fingridin tuulivoimaennusteeseen</div>
        <div id="api-key-container" style="margin-top: 1rem;">
            <input type="password" id="api-key" placeholder="Fingrid API Key"
                style="padding: 0.5rem; border-radius: 4px; border: 1px solid #ccc; width: 250px;">
            <button id="save-key"
                style="padding: 0.5rem 1rem; background: var(--accent-color); border: none; border-radius: 4px; color: white; cursor: pointer;">Tallenna</button>
        </div>
    </header>

    <main id="cards-container" class="grid-container">
        <!-- Cards will be injected here -->
    </main>

    <footer class="footer">
        <p>Ennuste perustuu historialliseen dataan hinnoista, tuulesta ja lämpötilasta (Helsinki, Tampere, Oulu).</p>
        <p>Malli: Hinta laskee epälineaarisesti tuulivoiman kasvaessa, ja kylmä sekä vähätuulisuus nostavat hintaa.</p>
        <div style="display: flex; gap: 0.75rem; justify-content: center; flex-wrap: wrap; margin-top: 1rem;">
            <button id="download-data"
                style="padding: 0.5rem; background: #334155; color: #fff; border: 1px solid #475569; border-radius: 4px; cursor: pointer;">Lataa
                kerätty data (CSV)</button>
            <button id="open-data-window"
                style="padding: 0.5rem; background: #1e293b; color: #fff; border: 1px solid #475569; border-radius: 4px; cursor: pointer;">Avaa kerätty data</button>
        </div>
        <section class="coeff-section" aria-labelledby="coeff-title">
            <h2 id="coeff-title">Algoritmin kertoimet</h2>
            <p>Muokkaa kertoimia ja näet ennusteet heti. Tallenna muokkaukset pysyviksi tai palauta oletukset.</p>
            <div class="coeff-grid">
                <label class="coeff-field">Perushinta
                    <input type="number" step="0.01" id="coeff-base" />
                </label>
                <label class="coeff-field">Tuulivoima (MW)
                    <input type="number" step="0.000001" id="coeff-wind" />
                </label>
                <label class="coeff-field">Tuulivoima²
                    <input type="number" step="0.000000001" id="coeff-wind-squared" />
                </label>
                <label class="coeff-field">Lämpötila (°C)
                    <input type="number" step="0.01" id="coeff-temp" />
                </label>
                <label class="coeff-field">Pakkaslisä
                    <input type="number" step="0.01" id="coeff-cold" />
                </label>
                <label class="coeff-field">Vähätuulisuuskerroin
                    <input type="number" step="0.01" id="coeff-low-wind" />
                </label>
                <label class="coeff-field">Pakkas * vähätuuli
                    <input type="number" step="0.001" id="coeff-cold-low-wind" />
                </label>
                <label class="coeff-field">Lattiataso
                    <input type="number" step="0.01" id="coeff-floor" />
                </label>
                <label class="coeff-field">Lauantai
                    <input type="number" step="0.01" id="coeff-sat" />
                </label>
                <label class="coeff-field">Sunnuntai
                    <input type="number" step="0.01" id="coeff-sun" />
                </label>
            </div>
            <div class="coeff-actions">
                <button type="button" class="coeff-save" id="save-coefficients">Tallenna kertoimet</button>
                <button type="button" class="coeff-reset" id="reset-coefficients">Palauta oletukset</button>
            </div>
        </section>
        <section class="history-comparison" aria-labelledby="history-title">
            <h3 id="history-title">Viimeiset toteutuneet päivät</h3>
            <p>Näytetään kaksi edellistä ennustetta ja niiden toteutunut keskivertohinta.</p>
            <div id="history-comparison-content">Ei vielä toteutuneita päiviä.</div>
        </section>
    </footer>

    <script>
        // Constants
        const FINGRID_API_URL = 'https://data.fingrid.fi/api/datasets/245/data'; // 245 = Wind Power Forecast
        const PROXY_CANDIDATES = [
            url => `https://cors.isomorphic-git.org/${url}`,
            url => `https://thingproxy.freeboard.io/fetch/${url}`,
            url => `https://corsproxy.io/?${encodeURIComponent(url)}`
        ];
        const OPEN_PROXY_CANDIDATES = [
            url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
        ];
        const LOCATIONS = [
            { name: "Helsinki", lat: 60.1695, lon: 24.9354 },
            { name: "Tampere", lat: 61.498, lon: 23.7608 },
            { name: "Oulu", lat: 65.0126, lon: 25.4715 }
        ];

        let apiKey = localStorage.getItem('fingrid_api_key') || '';

        // Model calibrated on 16.12.2025–7.2.2026 toteutuneilla hinnoilla (MAE ~2.52 snt)
        // Epälineaarinen regressio, jossa huomioidaan pakkaslisä ja vähätuulisuuden vaikutus.
        const DEFAULT_MODEL = {
            base_price: 15.08,
            coeff_wind_power: -0.005577,
            coeff_wind_power_squared: 0.000000541,
            coeff_temp: -0.149,
            coeff_cold: 0.538,
            coeff_low_wind: 2.78,
            coeff_cold_low_wind: 0.065,
            floor_price: 0.0,
            coeff_weekend_sat: 0.63,
            coeff_weekend_sun: -0.09
        };

        const LOW_WIND_THRESHOLD = 2000;

        let MODEL = loadStoredModel();
        let cachedForecastInputs = [];
        let cachedRecentHistoryInputs = [];
        let cachedRecentRealizedAverages = {};

        document.addEventListener('DOMContentLoaded', () => {
            const keyInput = document.getElementById('api-key');
            if (apiKey) {
                keyInput.value = apiKey;
                init();
            }

            document.getElementById('save-key').addEventListener('click', () => {
                const val = keyInput.value.trim();
                if (val) {
                    apiKey = val;
                    localStorage.setItem('fingrid_api_key', val);
                    init();
                }
            });

            document.getElementById('download-data').addEventListener('click', downloadLoggedData);
            document.getElementById('open-data-window').addEventListener('click', openLoggedDataWindow);
            document.getElementById('save-coefficients').addEventListener('click', saveCoefficients);
            document.getElementById('reset-coefficients').addEventListener('click', resetCoefficients);

            bindCoefficientInputs();
            syncCoefficientInputs();

            refreshHistoryFromServer();
        });

        function loadStoredModel() {
            const saved = localStorage.getItem('model_coefficients');
            if (!saved) return { ...DEFAULT_MODEL };
            try {
                const parsed = JSON.parse(saved);
                return {
                    ...DEFAULT_MODEL,
                    ...parsed
                };
            } catch (error) {
                console.warn('Invalid stored coefficients, resetting.', error);
                return { ...DEFAULT_MODEL };
            }
        }

        function parseNumber(value) {
            if (value === '' || value === null || value === undefined) return null;
            const normalized = value.toString().replace(',', '.');
            const num = Number(normalized);
            return Number.isFinite(num) ? num : null;
        }

        function bindCoefficientInputs() {
            const inputs = document.querySelectorAll('.coeff-section input');
            inputs.forEach(input => {
                input.addEventListener('input', () => {
                    updateModelFromInputs();
                    recalculateForecasts();
                });
            });
        }

        function syncCoefficientInputs() {
            const mapping = {
                base_price: 'coeff-base',
                coeff_wind_power: 'coeff-wind',
                coeff_wind_power_squared: 'coeff-wind-squared',
                coeff_temp: 'coeff-temp',
                coeff_cold: 'coeff-cold',
                coeff_low_wind: 'coeff-low-wind',
                coeff_cold_low_wind: 'coeff-cold-low-wind',
                floor_price: 'coeff-floor',
                coeff_weekend_sat: 'coeff-sat',
                coeff_weekend_sun: 'coeff-sun'
            };

            Object.entries(mapping).forEach(([key, id]) => {
                const input = document.getElementById(id);
                if (input) input.value = MODEL[key].toString();
            });
        }

        function updateModelFromInputs() {
            const mapping = {
                base_price: 'coeff-base',
                coeff_wind_power: 'coeff-wind',
                coeff_wind_power_squared: 'coeff-wind-squared',
                coeff_temp: 'coeff-temp',
                coeff_cold: 'coeff-cold',
                coeff_low_wind: 'coeff-low-wind',
                coeff_cold_low_wind: 'coeff-cold-low-wind',
                floor_price: 'coeff-floor',
                coeff_weekend_sat: 'coeff-sat',
                coeff_weekend_sun: 'coeff-sun'
            };

            Object.entries(mapping).forEach(([key, id]) => {
                const input = document.getElementById(id);
                if (!input) return;
                const value = parseNumber(input.value);
                if (value !== null) {
                    MODEL[key] = value;
                }
            });
        }

        function saveCoefficients() {
            localStorage.setItem('model_coefficients', JSON.stringify(MODEL));
            syncCoefficientInputs();
        }

        function resetCoefficients() {
            MODEL = { ...DEFAULT_MODEL };
            localStorage.removeItem('model_coefficients');
            syncCoefficientInputs();
            recalculateForecasts();
        }

        function recalculateForecasts() {
            if (!cachedForecastInputs.length) return;
            const forecast = applyModelToInputs(cachedForecastInputs);
            renderCards(forecast);
            updateHistoryComparison();
        }

        function getHistoryLog() {
            return JSON.parse(localStorage.getItem('history_log') || '[]');
        }

        function updateDownloadButtonText() {
            const history = getHistoryLog();
            const btn = document.getElementById('download-data');
            if (btn) btn.textContent = `Lataa kerätty data (CSV) - ${history.length} riviä`;
        }

        async function refreshHistoryFromServer() {
            try {
                const res = await fetch('/.netlify/functions/history');
                if (!res.ok) {
                    console.warn('Failed to load history from server.', res.status);
                    updateHistoryComparison();
                    return;
                }
                const payload = await res.json();
                const history = Array.isArray(payload.history) ? payload.history : [];
                localStorage.setItem('history_log', JSON.stringify(history));
            } catch (error) {
                console.warn('Failed to load history from server.', error);
            }
            updateDownloadButtonText();
            updateHistoryComparison();
        }

        async function saveHistoryEntry(entry) {
            try {
                const res = await fetch('/.netlify/functions/history', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ entry })
                });
                if (!res.ok) {
                    console.warn('Failed to save history to server.', res.status);
                    return;
                }
                const payload = await res.json();
                const history = Array.isArray(payload.history) ? payload.history : [];
                localStorage.setItem('history_log', JSON.stringify(history));
            } catch (error) {
                console.warn('Failed to save history to server.', error);
            }
            updateDownloadButtonText();
            updateHistoryComparison();
        }

        function getRealizedMapFromHistory() {
            const history = getHistoryLog();
            return history.reduce((acc, item) => {
                if (item.date && typeof item.realized_price === 'number') {
                    acc[item.date] = item.realized_price;
                }
                return acc;
            }, {});
        }

        function getDailyAveragesFromPriceData(priceJson) {
            const totals = {};
            const counts = {};
            if (priceJson.data && priceJson.data.fi) {
                priceJson.data.fi.forEach(point => {
                    const timeValue = point.timestamp ?? point.time ?? point.datetime;
                    const dateObj = new Date(timeValue);
                    if (Number.isNaN(dateObj.getTime())) return;
                    const dateStr = formatDateHelsinki(dateObj);
                    totals[dateStr] = (totals[dateStr] || 0) + point.price;
                    counts[dateStr] = (counts[dateStr] || 0) + 1;
                });
            }
            const averages = {};
            Object.keys(totals).forEach(dateStr => {
                const avgPrice = (totals[dateStr] / counts[dateStr]) * 1.24 * 0.1;
                averages[dateStr] = avgPrice;
            });
            return averages;
        }

        function updateHistoryComparison() {
            const container = document.getElementById('history-comparison-content');
            if (!container) return;

            const historyRealized = getRealizedMapFromHistory();
            const realizedMap = {
                ...cachedRecentRealizedAverages
            };
            Object.entries(historyRealized).forEach(([date, value]) => {
                if (typeof realizedMap[date] !== 'number') {
                    realizedMap[date] = value;
                }
            });

            let rows = cachedRecentHistoryInputs
                .map(item => ({
                    ...item,
                    realized_price: realizedMap[item.date]
                }))
                .filter(item => typeof item.realized_price === 'number');

            if (!rows.length) {
                const history = getHistoryLog();
                rows = history
                    .filter(item => item.date && typeof item.realized_price === 'number')
                    .map(item => ({
                        date: item.date,
                        windPower: item.predicted_wind_mw,
                        temp: item.predicted_temp,
                        dayOfWeek: new Date(item.date).getDay(),
                        realized_price: item.realized_price,
                        predicted_price: item.predicted_price
                    }));
            }

            rows = rows
                .sort((a, b) => new Date(a.date) - new Date(b.date))
                .slice(-2);

            if (rows.length === 0) {
                container.textContent = 'Ei vielä toteutuneita päiviä.';
                return;
            }

            const tableRows = rows.map(item => {
                const dateLabel = new Date(item.date).toLocaleDateString('fi-FI', { day: 'numeric', month: 'numeric' });
                const predictedValue = typeof item.predicted_price === 'number'
                    ? item.predicted_price
                    : calculatePriceForInputs(item.windPower, item.temp, new Date(item.date));
                const predicted = predictedValue.toFixed(2);
                const realized = item.realized_price.toFixed(2);
                const delta = (item.realized_price - predictedValue).toFixed(2);
                const deltaLabel = Number(delta) >= 0 ? `+${delta}` : delta;
                return `
                    <tr>
                        <td>${dateLabel}</td>
                        <td>${predicted} snt/kWh</td>
                        <td>${realized} snt/kWh</td>
                        <td>${deltaLabel} snt/kWh</td>
                    </tr>
                `;
            }).join('');

            container.innerHTML = `
                <table class="history-table">
                    <thead>
                        <tr>
                            <th>Päivä</th>
                            <th>Ennuste</th>
                            <th>Toteutunut keskiarvo</th>
                            <th>Ero</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${tableRows}
                    </tbody>
                </table>
            `;
        }

        function buildHistoryColumns(history) {
            const allKeys = new Set();
            history.forEach(obj => Object.keys(obj).forEach(k => allKeys.add(k)));
            allKeys.delete('date');
            return ['date', ...Array.from(allKeys).sort()];
        }

        async function init() {
            const container = document.getElementById('cards-container');
            container.innerHTML = '<div class="loading">Ladataan tietoja (Fingrid & OpenMeteo)...</div>';

            if (!apiKey) {
                container.innerHTML = '<div class="loading" style="color:var(--warning)">Syötä Fingrid API-avain yllä olevaan kenttään nähdäksesi ennusteen.</div>';
                return;
            }

            try {
                const [windData, weatherData, realizedData] = await Promise.all([
                    fetchFingridWindForecast(),
                    fetchWeatherForecasts(),
                    fetchRealizedData()
                ]);

                const [recentHistoryResult, recentRealizedResult] = await Promise.allSettled([
                    fetchRecentHistoryInputs(),
                    fetchRecentRealizedAverages()
                ]);
                cachedRecentHistoryInputs = recentHistoryResult.status === 'fulfilled' ? recentHistoryResult.value : [];
                cachedRecentRealizedAverages = recentRealizedResult.status === 'fulfilled' ? recentRealizedResult.value : {};

                cachedForecastInputs = mergeData(windData, weatherData);
                const forecast = applyModelToInputs(cachedForecastInputs);

                if (realizedData) {
                    logData(realizedData);
                }

                renderCards(forecast);
                updateHistoryComparison();

            } catch (error) {
                console.error(error);
                if (error.message.includes('401') || error.message.includes('403')) {
                    container.innerHTML = `<div class="loading" style="color:var(--danger)">Virhe: API-avain ei toimi (401/403). Tarkista avain.</div>`;
                } else {
                    container.innerHTML = `<div class="loading" style="color:var(--danger)">Virhe tietojen latauksessa: ${error.message}</div>`;
                }
            }
        }

        async function fetchFingridWindForecast() {
            const now = new Date();
            const startTime = now.toISOString();
            const endTime = new Date(now.getTime() + 4 * 24 * 60 * 60 * 1000).toISOString();
            const url = `${FINGRID_API_URL}?startTime=${startTime}&endTime=${endTime}&pageSize=200`;
            const proxyUrl = `/.netlify/functions/fingrid?startTime=${encodeURIComponent(startTime)}&endTime=${encodeURIComponent(endTime)}&pageSize=200`;

            const res = await fetch(proxyUrl, { headers: { 'x-api-key': apiKey } });
            if (!res.ok) throw new Error(`Fingrid API Error: ${res.status}`);
            return await res.json();
        }

        async function fetchRecentHistoryInputs() {
            const now = new Date();
            const endTime = new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000).toISOString();
            const startTime = new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000).toISOString();

            const windUrl = `${FINGRID_API_URL}?startTime=${startTime}&endTime=${endTime}&pageSize=200`;
            const windProxyUrl = `/.netlify/functions/fingrid?startTime=${encodeURIComponent(startTime)}&endTime=${encodeURIComponent(endTime)}&pageSize=200`;
            const windRes = await fetch(windProxyUrl, { headers: { 'x-api-key': apiKey } });
            if (!windRes.ok) throw new Error(`Fingrid API Error: ${windRes.status}`);
            const windData = await windRes.json();

            const weatherData = await fetchRecentWeatherHistories();

            const windByDay = {};
            windData.data.forEach(item => {
                const d = new Date(item.startTime);
                const dateStr = formatDateHelsinki(d);
                if (!windByDay[dateStr]) windByDay[dateStr] = { sum: 0, count: 0 };
                windByDay[dateStr].sum += item.value;
                windByDay[dateStr].count++;
            });

            const targetDates = getDateStringsForOffsets([-2, -1, 1, 2, 3]);
            return targetDates.reduce((acc, dateStr) => {
                const windStats = windByDay[dateStr];
                const avgTemp = weatherData[dateStr];
                if (windStats && windStats.count > 0 && typeof avgTemp === 'number') {
                    acc.push({
                        date: dateStr,
                        dayOfWeek: new Date(dateStr).getDay(),
                        windPower: windStats.sum / windStats.count,
                        temp: avgTemp
                    });
                }
                return acc;
            }, []);
        }

        async function fetchRecentWeatherHistories() {
            const recentTempsByDate = {};
            const recentDates = getDateStringsForOffsets([-2, -1, 1, 2, 3]);

            const promises = LOCATIONS.map(async loc => {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${loc.lat}&longitude=${loc.lon}&daily=temperature_2m_mean&timezone=Europe%2FHelsinki&past_days=2&forecast_days=3`;
                const res = await fetch(url);
                if (!res.ok) throw new Error(`Weather API failed for ${loc.name}`);
                return await res.json();
            });

            const responses = await Promise.all(promises);
            recentDates.forEach(dateStr => {
                let sumTemp = 0;
                let count = 0;
                responses.forEach(response => {
                    const dayIndex = response.daily.time.indexOf(dateStr);
                    if (dayIndex !== -1 && response.daily.temperature_2m_mean[dayIndex] !== null) {
                        sumTemp += response.daily.temperature_2m_mean[dayIndex];
                        count++;
                    }
                });
                if (count > 0) {
                    recentTempsByDate[dateStr] = sumTemp / count;
                }
            });

            return recentTempsByDate;
        }

        async function fetchRecentRealizedAverages() {
            const now = new Date();
            const start = new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000).toISOString();
            const end = now.toISOString();
            const proxyUrl = `/.netlify/functions/elering?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`;

            const priceRes = await fetch(proxyUrl);
            if (!priceRes.ok) throw new Error(`Elering status ${priceRes.status}`);
            const priceJson = await priceRes.json();

            const averages = getDailyAveragesFromPriceData(priceJson);
            const today = formatDateHelsinki(new Date());
            delete averages[today];
            return averages;
        }

        function getRecentDateStrings(days) {
            const dates = [];
            for (let i = days; i >= 1; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                dates.push(formatDateHelsinki(date));
            }
            return dates;
        }

        function getDateStringsForOffsets(offsets) {
            return offsets.map(offset => {
                const date = new Date();
                date.setDate(date.getDate() + offset);
                return formatDateHelsinki(date);
            });
        }

        function formatDateHelsinki(date) {
            return new Intl.DateTimeFormat('en-CA', {
                timeZone: 'Europe/Helsinki',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            }).format(date);
        }

        async function fetchWeatherForecasts() {
            const promises = LOCATIONS.map(async loc => {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${loc.lat}&longitude=${loc.lon}&daily=temperature_2m_mean&timezone=Europe%2FHelsinki&forecast_days=5`;
                const res = await fetch(url);
                if (!res.ok) throw new Error(`Weather API failed for ${loc.name}`);
                return await res.json();
            });
            return Promise.all(promises);
        }

        async function fetchRealizedData() {
            try {
                const now = new Date();
                const start = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000).toISOString();
                const end = now.toISOString();

                // Use CORS Proxy for Elering too
                const proxyUrl = `/.netlify/functions/elering?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`;

                const priceRes = await fetch(proxyUrl);
                if (!priceRes.ok) throw new Error(`Elering status ${priceRes.status}`);

                const priceJson = await priceRes.json();

                const averages = getDailyAveragesFromPriceData(priceJson);
                const today = formatDateHelsinki(new Date());
                delete averages[today];
                const dates = Object.keys(averages).sort();
                const latestDate = dates[dates.length - 1];
                if (latestDate) {
                    const avgPrice = averages[latestDate];
                    console.log(`Logataan toteutunut hinta: ${avgPrice.toFixed(2)} snt/kWh`);
                    return {
                        date: latestDate,
                        realized_price: avgPrice,
                        source: 'elering',
                        timestamp: new Date().toISOString()
                    };
                }
                return null;
            } catch (e) {
                console.warn("Failed to fetch realized data", e);
                return null;
            }
        }

        async function fetchJsonWithFallback(url, options = {}, proxies = []) {
            const attempts = [u => u, ...proxies];
            let lastError;

            for (const proxy of attempts) {
                try {
                    const proxiedUrl = proxy(url);
                    const res = await fetch(proxiedUrl, options);
                    if (!res.ok) {
                        throw new Error(`HTTP ${res.status} (${proxiedUrl})`);
                    }
                    return await res.json();
                } catch (error) {
                    lastError = error;
                }
            }

            throw lastError || new Error('Network request failed');
        }

        function logData(data) {
            if (!data) return;
            let history = getHistoryLog();
            const idx = history.findIndex(h => h.date === data.date);

            if (idx >= 0) {
                const existing = history[idx];
                const shouldPreserveRealized = typeof existing.realized_price === 'number'
                    && typeof data.realized_price !== 'number';
                history[idx] = {
                    ...existing,
                    ...data,
                    realized_price: shouldPreserveRealized ? existing.realized_price : data.realized_price
                };
            } else {
                history.push(data);
            }

            history.sort((a, b) => new Date(a.date) - new Date(b.date));
            localStorage.setItem('history_log', JSON.stringify(history));
            updateDownloadButtonText();
            updateHistoryComparison();
            saveHistoryEntry(data);
        }

        function downloadLoggedData() {
            const history = JSON.parse(localStorage.getItem('history_log') || '[]');
            if (history.length === 0) {
                alert("Ei tallennettua dataa.");
                return;
            }

            const sortedKeys = buildHistoryColumns(history);

            const header = sortedKeys.join(',');
            const rows = history.map(obj => {
                return sortedKeys.map(k => {
                    const val = obj[k];
                    if (val === undefined) return '';
                    if (typeof val === 'number') return val.toFixed(2);
                    return val;
                }).join(',');
            });

            const csvContent = "data:text/csv;charset=utf-8," + [header, ...rows].join('\n');
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "calibration_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function openLoggedDataWindow() {
            const history = JSON.parse(localStorage.getItem('history_log') || '[]');
            if (history.length === 0) {
                alert("Ei tallennettua dataa.");
                return;
            }

            const sortedKeys = buildHistoryColumns(history);
            const win = window.open('', '_blank');
            if (!win) {
                alert("Ponnahdusikkuna estetty. Salli ponnahdusikkuna nähdäksesi datan.");
                return;
            }

            const rows = history.map(obj => {
                return `<tr>${sortedKeys.map(k => {
                    const val = obj[k];
                    if (val === undefined) return '<td></td>';
                    if (typeof val === 'number') return `<td>${val.toFixed(2)}</td>`;
                    return `<td>${val}</td>`;
                }).join('')}</tr>`;
            }).join('');

            win.document.write(`
                <html>
                <head>
                    <title>Kerätty data</title>
                    <style>
                        body { font-family: ${JSON.stringify(getComputedStyle(document.body).fontFamily || 'Arial')}; margin: 20px; color: #0f172a; }
                        table { border-collapse: collapse; width: 100%; }
                        th, td { border: 1px solid #e2e8f0; padding: 8px; text-align: left; }
                        th { background: #f1f5f9; }
                        tbody tr:nth-child(even) { background: #f8fafc; }
                    </style>
                </head>
                <body>
                    <h2>Kerätty data (${history.length} riviä)</h2>
                    <table>
                        <thead><tr>${sortedKeys.map(k => `<th>${k}</th>`).join('')}</tr></thead>
                        <tbody>${rows}</tbody>
                    </table>
                </body>
                </html>
            `);
            win.document.close();
        }

        function mergeData(fingridData, weatherData) {
            const windByDay = {};
            fingridData.data.forEach(item => {
                const d = new Date(item.startTime);
                const dateStr = d.toLocaleDateString('en-CA');
                if (!windByDay[dateStr]) windByDay[dateStr] = { sum: 0, count: 0 };
                windByDay[dateStr].sum += item.value;
                windByDay[dateStr].count++;
            });

            const days = weatherData[0].daily.time;
            const finalData = [];

            days.forEach((dateStr, index) => {
                if (index < 1 || index > 4) return;

                // Date Check for Weekend
                const dateObj = new Date(dateStr);
                const dayOfWeek = dateObj.getDay();

                let avgTemp = 0;
                weatherData.forEach(loc => {
                    if (loc.daily.temperature_2m_mean[index] !== null) {
                        avgTemp += loc.daily.temperature_2m_mean[index];
                    }
                });
                avgTemp /= weatherData.length;

                const windStats = windByDay[dateStr];
                if (windStats && windStats.count > 0) {
                    const avgWindPower = windStats.sum / windStats.count;

                    finalData.push({
                        date: dateStr,
                        dayOfWeek,
                        windPower: avgWindPower,
                        temp: avgTemp
                    });
                }
            });

            return finalData;
        }

        function applyModelToInputs(inputs) {
            return inputs.map(input => {
                // Model Calc (signed coefficients)
                const price = calculatePriceForInputs(input.windPower, input.temp, input.dayOfWeek);

                // Log Forecast
                logData({
                    date: input.date,
                    predicted_price: price,
                    predicted_wind_mw: input.windPower,
                    predicted_temp: input.temp
                });

                return {
                    date: input.date,
                    price,
                    windPower: input.windPower,
                    temp: input.temp
                };
            });
        }

        function calculatePriceForInputs(windPower, temp, dayOfWeekOrDate) {
            const dayOfWeek = dayOfWeekOrDate instanceof Date
                ? dayOfWeekOrDate.getDay()
                : dayOfWeekOrDate;
            const cold = Math.max(0, -temp);
            const lowWindFactor = Math.max(0, Math.min(1, (LOW_WIND_THRESHOLD - windPower) / LOW_WIND_THRESHOLD));
            let rawPrice = MODEL.base_price
                + (windPower * MODEL.coeff_wind_power)
                + (windPower * windPower * MODEL.coeff_wind_power_squared)
                + (temp * MODEL.coeff_temp)
                + (cold * MODEL.coeff_cold)
                + (lowWindFactor * MODEL.coeff_low_wind)
                + (cold * lowWindFactor * MODEL.coeff_cold_low_wind);

            if (dayOfWeek === 6) rawPrice += MODEL.coeff_weekend_sat;
            if (dayOfWeek === 0) rawPrice += MODEL.coeff_weekend_sun;

            return Math.max(MODEL.floor_price, rawPrice);
        }

        function renderCards(data) {
            const container = document.getElementById('cards-container');
            container.innerHTML = '';

            if (data.length === 0) {
                container.innerHTML = '<div class="loading">Ei tarpeeksi dataa ennusteen luomiseksi.</div>';
                return;
            }

            data.forEach(day => {
                const card = document.createElement('div');
                card.className = 'card';

                const dateObj = new Date(day.date);
                const dayName = dateObj.toLocaleDateString('fi-FI', { weekday: 'long' });
                const dateStr = dateObj.toLocaleDateString('fi-FI', { day: 'numeric', month: 'numeric' });

                const priceFormatted = day.price.toFixed(2);

                let priceClass = 'price-mid';
                if (day.price < 5) priceClass = 'price-low';
                if (day.price > 15) priceClass = 'price-high';

                card.innerHTML = `
            <div class="card-header">
                <span class="date">${dateStr}</span>
                <span class="weekday">${dayName}</span>
            </div>
            <div class="price-container">
                <div class="price-value ${priceClass}">${priceFormatted}</div>
                <div class="price-unit">snt/kWh (sis. ALV)</div>
            </div>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-label">Lämpötila</span>
                    <span class="stat-value">${day.temp.toFixed(1)}°C</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Tuulivoima</span>
                    <span class="stat-value">${Math.round(day.windPower)} MW</span>
                </div>
            </div>
        `;

                container.appendChild(card);
            });
        }
    </script>
</body>

</html>
